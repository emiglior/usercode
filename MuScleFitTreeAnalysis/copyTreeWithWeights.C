void copyTreeWithWeights(){

  // macro to clone the tree overwriting the weight with the equivalent lumi
  // usage: root -l copyTreeWithWeights.C
  // then create a uniquw TTree with: hadd GenMuonAnalyzerHistos_PFS_afterFSRv2_POWHEG_50_800_NoCuts_Weighted.root powheg_M50_120.root powheg_M120_200.root powheg_M200_400.root powheg_M400_800.root 
  
  // based on $ROOTSYS/tutorials/tree/copytree3.C
  // Example of Root macro to copy a subset of a Tree to a new Tree
  // Only selected entries are copied to the new Tree.
  // Author: Rene Brun

  // libMuScleFit.so created in the Makefile
  gSystem->Load("libMuScleFit");

  // Define for each dataset: weight, acceptance cut (to remove spurious mu+mu- pairs generated by pythia8)
  const Int_t nsample(4);
  Double_t lumi = 3000.; // set a lumi value to avoid too small weights

  char oldfile_name[nsample][70] = {
    "GenMuonAnalyzerHistos_PFS_afterFSRv2_POWHEG_50_120_NoCuts.root",
    "GenMuonAnalyzerHistos_PFS_afterFSRv2_POWHEG_120_200_NoCuts.root",
    "GenMuonAnalyzerHistos_PFS_afterFSRv2_POWHEG_200_400_NoCuts.root",
    "GenMuonAnalyzerHistos_PFS_afterFSRv2_POWHEG_400_800_NoCuts.root"    
  };

  char newfile_name[nsample][40] = {
    "powheg_M50_120.root",
    "powheg_M120_200.root",
    "powheg_M200_400.root",
    "powheg_M400_800.root",
  };

  Double_t new_weights[nsample] = {
    lumi*1975.0*1.006/2800076,
    lumi*19.32*1.006/98400,
    lumi*2.731*1.006/79600,
    lumi*0.241*1.006/100000
  };

  Double_t min_mLL[nsample] = {
    50.,
    120.,
    200.,
    400.
  };

  Double_t max_mLL[nsample] = {
    120.,
    200.,
    400.,
    800.
  };
  // end of definitions    

  TLorentzVector* muNegGen=0;
  TLorentzVector* muPosGen=0;
  
  GenMuonPair *mupairGenIN_ = 0;
  double genweight_ = 0;
  double lheweight_ = 0;

  for (Int_t is=0; is<nsample; is++) {                        // loop on the samples

    std::cout << newfile_name[is] << std::endl;

    //Get old file, old tree and set top branch address
    TFile *oldfile = new TFile(oldfile_name[is]);
    TTree *oldtree = (TTree*)oldfile->Get("demo/T");
    Long64_t nentries = oldtree->GetEntries();

    oldtree->SetBranchAddress("GenMuons",    &mupairGenIN_); //select generated event    
    oldtree->SetBranchAddress("genweight",   &genweight_);
    oldtree->SetBranchAddress("lheweight",   &lheweight_);

    // Create a new file + a clone of old tree in new file
    TFile *newfile = new TFile(newfile_name[is],"recreate");

    newfile->mkdir("demo");
    newfile->cd("demo");
    TTree *newtree = oldtree->CloneTree(0);

    for (Long64_t i=0;i<nentries; i++) {
      oldtree->GetEntry(i);      
      genweight_ = new_weights[is];      


      // fetch GEN muons from the input tree
      muNegGen = new TLorentzVector(mupairGenIN_->mu1.fP4.Px(), mupairGenIN_->mu1.fP4.Py(), mupairGenIN_->mu1.fP4.Pz(), mupairGenIN_->mu1.fP4.E());
      muPosGen = new TLorentzVector(mupairGenIN_->mu2.fP4.Px(), mupairGenIN_->mu2.fP4.Py(), mupairGenIN_->mu2.fP4.Pz(), mupairGenIN_->mu2.fP4.E());      

      Double_t mLL = ((*muNegGen)+(*muPosGen)).M();
      if ( mLL >= min_mLL[is]  &&  mLL <= max_mLL[is] ) 
       	newtree->Fill();

      if ( muNegGen != 0 ) delete muNegGen; 
      if ( muPosGen != 0 ) delete muPosGen;      

      
    }
    //    newtree->Print();
    newtree->AutoSave();
    if ( oldfile!=0 ) delete oldfile;
    if ( newfile!=0 ) delete newfile;


  } // end of loop on the samples

}
